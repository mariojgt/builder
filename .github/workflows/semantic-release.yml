name: Semantic Release

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    types: [closed]
    branches:
      - main

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  semantic-release:
    if: github.event_name == 'push' || (github.event.pull_request.merged == true)
    runs-on: ubuntu-latest

    permissions:
      contents: write
      issues: write
      pull-requests: write

    outputs:
      new_version: ${{ steps.semantic.outputs.new_version }}
      previous_version: ${{ steps.semantic.outputs.previous_version }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install semantic-release
      run: |
        npm install -g @semantic-release/changelog @semantic-release/git semantic-release

    - name: Get current version
      id: current_version
      run: |
        # Get the latest tag
        latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "current_version=$latest_tag" >> $GITHUB_OUTPUT
        echo "Current version: $latest_tag"

    - name: Analyze commits and determine version bump
      id: semantic
      run: |
        # Get commit messages since last tag
        latest_tag="${{ steps.current_version.outputs.current_version }}"

        if [ "$latest_tag" = "v0.0.0" ]; then
          commits=$(git log --pretty=format:"%s" HEAD)
        else
          commits=$(git log --pretty=format:"%s" ${latest_tag}..HEAD)
        fi

        echo "Analyzing commits:"
        echo "$commits"

        # Initialize bump type
        bump_type="none"

        # Check for version bump indicators in commit messages
        while IFS= read -r commit; do
          echo "Checking commit: $commit"

          # Major version bumps (breaking changes)
          if echo "$commit" | grep -iE "(major|breaking|BREAKING CHANGE|!:|feat!:|fix!:)" > /dev/null; then
            bump_type="major"
            echo "Found major change indicator"
            break
          fi

          # Minor version bumps (new features)
          if echo "$commit" | grep -iE "(minor|feat:|feature:|add:|new:)" > /dev/null; then
            if [ "$bump_type" != "major" ]; then
              bump_type="minor"
              echo "Found minor change indicator"
            fi
          fi

          # Patch version bumps (bug fixes)
          if echo "$commit" | grep -iE "(patch|fix:|bugfix:|hotfix:|docs:|style:|refactor:|test:|chore:)" > /dev/null; then
            if [ "$bump_type" = "none" ]; then
              bump_type="patch"
              echo "Found patch change indicator"
            fi
          fi
        done <<< "$commits"

        # If no specific indicators found but there are commits, default to patch
        if [ "$bump_type" = "none" ] && [ -n "$commits" ]; then
          bump_type="patch"
        fi

        # Calculate new version
        if [ "$bump_type" != "none" ]; then
          version=${latest_tag#v}
          IFS='.' read -ra VERSION_PARTS <<< "$version"
          major=${VERSION_PARTS[0]:-0}
          minor=${VERSION_PARTS[1]:-0}
          patch=${VERSION_PARTS[2]:-0}

          case $bump_type in
            "major")
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            "minor")
              minor=$((minor + 1))
              patch=0
              ;;
            "patch")
              patch=$((patch + 1))
              ;;
          esac

          new_version="v$major.$minor.$patch"
        else
          new_version="$latest_tag"
        fi

        echo "bump_type=$bump_type" >> $GITHUB_OUTPUT
        echo "new_version=$new_version" >> $GITHUB_OUTPUT
        echo "previous_version=$latest_tag" >> $GITHUB_OUTPUT

        echo "Bump type: $bump_type"
        echo "New version: $new_version"

    - name: Generate changelog
      id: changelog
      if: steps.semantic.outputs.bump_type != 'none'
      run: |
        latest_tag="${{ steps.semantic.outputs.previous_version }}"
        new_version="${{ steps.semantic.outputs.new_version }}"

        # Generate changelog from commits
        if [ "$latest_tag" = "v0.0.0" ]; then
          changelog=$(git log --pretty=format:"- %s (%h)" HEAD)
        else
          changelog=$(git log --pretty=format:"- %s (%h)" ${latest_tag}..HEAD)
        fi

        # Categorize commits
        features=""
        fixes=""
        others=""
        breaking=""

        while IFS= read -r line; do
          if echo "$line" | grep -iE "(feat:|feature:|add:|new:)" > /dev/null; then
            features="$features$line"$'\n'
          elif echo "$line" | grep -iE "(fix:|bugfix:|hotfix:)" > /dev/null; then
            fixes="$fixes$line"$'\n'
          elif echo "$line" | grep -iE "(major|breaking|BREAKING CHANGE|!:|feat!:|fix!:)" > /dev/null; then
            breaking="$breaking$line"$'\n'
          else
            others="$others$line"$'\n'
          fi
        done <<< "$changelog"

        # Build formatted changelog
        formatted_changelog="## Changes in $new_version"$'\n\n'

        if [ -n "$breaking" ]; then
          formatted_changelog="$formatted_changelog### üö® Breaking Changes"$'\n'"$breaking"$'\n'
        fi

        if [ -n "$features" ]; then
          formatted_changelog="$formatted_changelog### ‚ú® New Features"$'\n'"$features"$'\n'
        fi

        if [ -n "$fixes" ]; then
          formatted_changelog="$formatted_changelog### üêõ Bug Fixes"$'\n'"$fixes"$'\n'
        fi

        if [ -n "$others" ]; then
          formatted_changelog="$formatted_changelog### üìù Other Changes"$'\n'"$others"$'\n'
        fi

        # Save to file and output
        echo "$formatted_changelog" > CHANGELOG_TEMP.md
        echo "changelog_file=CHANGELOG_TEMP.md" >> $GITHUB_OUTPUT

    - name: Create and push tag
      if: steps.semantic.outputs.bump_type != 'none'
      run: |
        new_version="${{ steps.semantic.outputs.new_version }}"
        bump_type="${{ steps.semantic.outputs.bump_type }}"

        # Check if tag already exists
        if git rev-parse "$new_version" >/dev/null 2>&1; then
          echo "Tag $new_version already exists, skipping..."
          exit 0
        fi

        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        # Create annotated tag
        git tag -a "$new_version" -m "Release $new_version ($bump_type bump)"

        # Push tag
        git push origin "$new_version"

        echo "‚úÖ Created and pushed tag: $new_version"

    - name: Create GitHub Release
      if: steps.semantic.outputs.bump_type != 'none'
      uses: actions/create-release@v1
      with:
        tag_name: ${{ steps.semantic.outputs.new_version }}
        release_name: Release ${{ steps.semantic.outputs.new_version }}
        body_path: ${{ steps.changelog.outputs.changelog_file }}
        draft: false
        prerelease: false

    - name: Update composer.json version (optional)
      if: steps.semantic.outputs.bump_type != 'none'
      run: |
        new_version="${{ steps.semantic.outputs.new_version }}"
        version_number=${new_version#v}  # Remove 'v' prefix

        # Check if composer.json has a version field and update it
        if [ -f "composer.json" ]; then
          # Create a backup
          cp composer.json composer.json.bak

          # Try to update version field if it exists
          if grep -q '"version"' composer.json; then
            sed -i.bak 's/"version": "[^"]*"/"version": "'$version_number'"/g' composer.json
            echo "Updated version in composer.json to $version_number"

            # Commit the change
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add composer.json
            git commit -m "chore: bump version to $new_version [skip ci]"
            git push origin main
          else
            echo "No version field in composer.json, skipping update"
          fi
        fi

    - name: Summary
      if: steps.semantic.outputs.bump_type != 'none'
      run: |
        echo "üéâ Successfully created release ${{ steps.semantic.outputs.new_version }}"
        echo "üìà Bump type: ${{ steps.semantic.outputs.bump_type }}"
        echo "üì¶ Previous version: ${{ steps.semantic.outputs.previous_version }}"
        echo "üè∑Ô∏è New tag created and pushed"
        echo "üìã GitHub release created"
